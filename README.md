# 演習問題 仕様書

## 演習 1

- **プログラム名**
  - `ExamTenThread`
- **目的**
  - `Thread`クラスの拡張による基本的なスレッドの作成方法と、配列を使用した複数スレッドの管理方法を習得する。
- **クラス仕様**
  - **`ExamTenThread`クラス**
    - `main`メソッドを持つメインプログラムである。
    - プログラムの最初に `"programmed by 自分の名前"` という形式で自分の名前を出力する。
    - `MyThread`型のインスタンスを 10 個格納する配列 `threads` を持つ。
    - `for`ループ内で`MyThread`のインスタンスを 10 個作成し、配列に格納すると同時に、各スレッドをスタートさせる。
  - **`MyThread`クラス**
    - `Thread`クラスを拡張したクラスである。
    - `run`メソッド内で、自身のスレッド名を出力する機能を持つ。
- **実行結果例**

```text
  java ExamTenThread
  programmed by 自分の名前
  Thread-0
  Thread-1
  Thread-2
  Thread-4
  Thread-5
  Thread-6
  Thread-3
  Thread-8
  Thread-7
  Thread-9
```

- **注記**: スレッドの出力順は上記と異なる場合がある。

---

## 演習 2

- **プログラム名**
  - `ExamThreadCompany`
- **目的**
  - それぞれ異なる処理を行う、複数のスレッドクラスを作成し、実行する方法を習得する。
- **クラス仕様**
  - **`ExamThreadCompany`クラス**
    - `main`メソッドを持つメインプログラムである。
    - `Engineer`クラスと`Salesman`クラスのインスタンスをそれぞれ作成し、スタートさせる。
  - **`Engineer`クラス**
    - `Thread`クラスを拡張したクラスである。
    - `run`メソッド内で、`"車を作っています"` と出力する。
  - **`Salesman`クラス**
    - `Thread`クラスを拡張したクラスである。
    - `run`メソッド内で、`"車を売っています"` と出力する。
- **実行結果例**

```text
  java ExamThreadCompany
  programmed by 上田剛瑠
  車を作っています
  車を売っています
```

---

## 演習 3

- **プログラム名**
  - `ExamThread1`
- **目的**
  - `Thread`クラスを拡張して作成された既存のプログラムを、`Runnable`インタフェースを実装する方法に書き換える。
- **変更仕様**
  - 提示された`ExamThread1.java`のプログラムを修正する。
  - `MyThread`クラスを、`Thread`クラスの拡張ではなく`Runnable`インタフェースの実装に変更する。
  - `main`メソッド内では、`Runnable`を実装したクラスのインスタンスを生成し、それを元に`Thread`オブジェクトを生成して`start`させる形式に変更する。
  - "上田剛瑠"の部分は自分の名前に変更する。
- **実行結果例**

```text
  java ExamThread1
  上田剛瑠1の1回目
  上田剛瑠2の1回目
  上田剛瑠2の2回目
  上田剛瑠1の2回目
  上田剛瑠2の3回目
  上田剛瑠1の3回目
  上田剛瑠2の4回目
  上田剛瑠1の4回目
  上田剛瑠2の5回目
  上田剛瑠1の5回目
```

---

## 演習 4

- **プログラム名**
  - `ExamThreadJoin`
- **目的**
  - `join()`メソッドを使用し、特定のスレッドの処理が完了するまで待機する処理を実装する。
- **クラス仕様**
  - **`ExamThreadJoin`クラス**
    - メインスレッド（メインプログラム）である。
    - `ThreadA`のインスタンスを生成してスタートさせ、そのスレッドの処理が終了するのを`join`メソッドで待つ。
    - 自身の処理の開始時と終了時にメッセージを出力する。
  - **`ThreadA`クラス**
    - `Thread`を拡張したクラスである。
    - `ThreadB`のインスタンスを生成してスタートさせ、そのスレッドの処理が終了するのを`join`メソッドで待つ。
    - 自身の処理の開始時と終了時にメッセージを出力する。
  - **`ThreadB`クラス**
    - `Thread`を拡張したクラスである。
    - 自身の処理の開始時と終了時にメッセージを出力する。
- **実行結果例**

```text
  java ExamThreadJoin
  programmed by 上田剛瑠
  ExamThreadJoin　開始
  ThreadA 開始
  ThreadB 開始
  threadB 終了
  threadA 終了
  ExamThreadJoin　終了
```

---

## 演習 5

- **プログラム名**
  - `ExamThreadJoin2`
- **目的**
  - 演習 4 の内容を、`Runnable`インタフェースを実装する方法で実現する。
- **変更仕様**
  - 演習 4 で作成した`ThreadA`と`ThreadB`を、`Runnable`インタフェースを実装するクラスとして再定義する。
  - その他の動作（`join`の呼び出しやメッセージ出力など）は演習 4 と同一とする。
- **実行結果例**

```text
  java ExamThreadJoin2
  programmed by 上田剛瑠
  ExamThreadJoin　開始
  ThreadA 開始
  ThreadB 開始
  threadB 終了
  threadA 終了
  ExamThreadJoin　終了
```

---

## 演習 6

- **プログラム名**
  - `ExamThreadCounter`
- **目的**
  - 複数スレッドからの共有リソースへのアクセス時に発生する競合状態の問題を理解し、`synchronized`ブロックによる排他制御を用いて正しく修正する。
- **変更仕様**
  - 提示された不完全なプログラム`ExThreadCounter`を修正する。
  - **`Counter`クラス**:
    - `increment`および`decrement`メソッドが、共有変数`value`を同時に更新しようとして発生する競合状態を解消する。
    - **ヒント**: `increment`および`decrement`メソッド内の共有変数を操作する部分を、`synchronized`ブロックで排他制御する。ロック対象はフィールド変数`value`とするが、`int`のような基本データ型はロックオブジェクトにできないため、`value`をオブジェクトでラップ（包み込む）する必要がある。
  - **`main`メソッド**:
    - `Adder`スレッドと`Subtracter`スレッドの処理が完了するのを`join`で待ち、最終的な`counter`の`value`値を出力する。
- **実行後の期待値**
  - 100 回のインクリメントと 100 回のデクリメントの結果、`counter`の値が最終的に`0`になること。
- **修正後の実行結果例**

```text
java ExamThreadCounter
programmed by 上田剛瑠
100回インクリメントしました
100回デクリメントしました
counterの値=0
```

---

## 演習問題 2-1

- **プログラム名**
  - `ExamGBouncingBall`
- **目的**
  - HTMLファイルからパラメータを読み込み、それに基づいてオブジェクトを動かす基本的なアニメーションを作成する。壁での反射処理を実装する。
- **機能仕様**
  - 半径10のボールを画面内で動かす。
  - ボールの位置 `(x, y)` は、速度 `(vx, vy)` に基づいて `x = x + vx`, `y = y + vy` のように更新される。
  - ボールがアプレットの上下左右の端に到達した場合、反射するように速度を反転させる。
- **技術仕様**
  - 初期座標 `(x, y)` と初速度 `(vx, vy)` は、HTMLの `<param>` タグから受け取る。
  - `getParameter()` で取得した値は文字列であるため、`Integer.parseInt()` を用いて整数に変換する必要がある。
- **HTMLパラメータ例**
  - `x`: "100"
  - `y`: "200"
  - `vx`: "3"
  - `vy`: "4"

---

## 演習問題 2-2

- **プログラム名**
  - `ExamGLineArt`
- **目的**
  - 複数のオブジェクトを独立して動かし、それらを関連付けた描画を行う。
- **機能仕様**
  - 2つの点 P1(`x1`, `y1`) と P2(`x2`, `y2`) を、それぞれの速度に基づいて自由運動させる。
  - 各点がアプレットの境界にぶつかった場合、完全弾性反射（速度の反転）を行う。
  - 常に点P1と点P2を結ぶ赤い線分を描画する。
- **技術仕様**
  - ダブルバッファリングを実装する。
  - アニメーションの周期は50msとする。
  - 各点の初期座標と初速度は、HTMLの `<param>` タグから受け取る。

---

## 演習問題 2-3

- **プログラム名**
  - `ExamGFlyingMessage`
- **目的**
  - フォントサイズを動的に変更し、遠近感のあるアニメーションを作成する。
- **機能仕様**
  - HTMLから受け取った一つのメッセージ文字列が、画面の奥から手前に向かって近づいてくるように見せる。
  - **ヒント**: 文字列の中心座標を画面中央で固定したまま、文字サイズを徐々に大きくすることで実現する。
- **技術仕様**
  - ダブルバッファリングを実装する。

---

## 演習問題 2-4

- **プログラム名**
  - `ExamGBouncingBall2`
- **目的**
  - 複数のオブジェクト同士の衝突判定と、衝突時の処理を実装する。
- **機能仕様**
  - 半径20のボールを2つ動かす。
  - 各ボールはアプレットの端で反射する。
  - ボール同士が衝突した場合、反射するように見せる。
  - 衝突処理は簡易的なものとし、衝突を検出したら互いの速度を反転させるだけで良い。
- **技術仕様**
  - 2つのボールの初期座標と初速度は、HTMLの `<param>` タグから受け取る。

---

## 演習問題 2-5

- **プログラム名**
  - `ExamGAnimeMouth`
- **目的**
  - 単純なパーツの動きを組み合わせ、キャラクターアニメーションの基礎を実装する。
- **機能仕様**
  - 口が「開く」状態と「閉じる」状態を繰り返すアニメーションを作成する。
  - （詳細な形状や動きは指定されていないため、実装は自由）

---

## 演習問題 2-6

- **プログラム名**
  - `ExamGAnimeWalk`
- **目的**
  - 複数のパーツ（手足）を連動させ、より複雑なキャラクターアニメーションを作成する。
- **機能仕様**
  - 人間が手と足を振って歩行しているように見えるアニメーションを作成する。
  - （詳細な形状や動きは指定されていないため、実装は自由）

---

## 演習問題 2-7

- **プログラム名**
  - `ExamGBouncingBall3`
- **目的**
  - アニメーションにUI（ボタン）を追加し、ユーザの操作によってアニメーションの実行・停止を制御する方法を習得する。
- **機能仕様**
  - 演習1の `ExamGBouncingBall` のプログラムをベースとする。
  - アプレット内に「スタート(start)」ボタンと「ストップ(stop)」ボタンを追加する。
  - スタートボタンを押すとアニメーションが開始・再開し、ストップボタンを押すとアニメーションが停止する。

---

## 演習問題 2-8

- **プログラム名**
  - `ExamGTrafficSignal`
- **目的**
  - 状態遷移とタイマーに基づいた、実用的なテーマのアニメーションを作成する。
- **機能仕様**
  - 信号機の形をしたアニメーションであること。
  - 点灯は「赤(10秒) → 青(10秒) → 黄(2秒)」の順序と時間で行うこと。
  - 各信号の残り時間を、10段階で視覚的に表示すること。
  - 信号機の形状や大きさは自由にデザインしてよい。
- **技術仕様**
  - ダブルバッファリングを実装すること。

---

## 演習問題 2-9

- **プログラム名**
  - `ExamGAnalogClock`
- **目的**
  - 現在時刻を取得し、三角関数などを利用して針の角度を計算し、アナログ時計をリアルタイムに描画する。
- **機能仕様**
  - 現在時刻を示すアナログ時計を作成する。
  - 時計の針（時・分・秒）が正しく動作すること。
  - 時計の形状やデザインは自由である。
